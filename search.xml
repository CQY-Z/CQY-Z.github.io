<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++的一些笔记</title>
      <link href="/2020/04/26/C_C++/"/>
      <url>/2020/04/26/C_C++/</url>
      
        <content type="html"><![CDATA[<h1 id="记一些函数的作用"><a href="#记一些函数的作用" class="headerlink" title="记一些函数的作用"></a>记一些函数的作用</h1><ul><li>floor()、ceil()与round()的不同点：floor直接舍去后面的数字  <pre><code>ceil()只要后面还有小数就会进一  </code></pre></li><li>随机生成一个数字：<ol><li>srand(time(nullptr));</li><li>rand();</li></ol></li><li>getline()有2种用法：<blockquote><p>第一种：<br>  在<istream>中的getline()函数有两种重载形式：<br>  getline (char* s, streamsize n );<br>  getline (char* s, streamsize n, char delim );<br>  作用是： 从istream中读取至多n个字符(包含结束标记符)保存在s对应的数组中。即使还没读够n个字符，</istream></p><pre><code>如果遇到delim或 字数达到限制，则读取终止，delim都不会被保存进s对应的数组中。</code></pre><p>第二种：<br>  在<string>中的getline函数有四种重载形式：<br>  getline (istream&amp;  is, string&amp; str, char delim);<br>  getline (istream&amp;&amp; is, string&amp; str, char delim);<br>  getline (istream&amp;  is, string&amp; str);<br>  getline (istream&amp;&amp; is, string&amp; str);<br>  函数的变量：<br>  is    ：表示一个输入流，例如cin。<br>  str   ：string类型的引用，用来存储输入流中的流信息。<br>  delim ：char类型的变量，所设置的截断字符；在不自定义设置的情况下，遇到’\n’，则终止输入。</string></p></blockquote></li><li>cin.ignore(int intExp, char chExp)：intExp 是一个整型表达式，也可以是一个整型数值，这个数值表示在一行中忽略的字符的最大数目，比如说intExp=100；<pre><code>chExp,是一个字符表达式。表示如果遇到一个字符值等于chEXP，那么就停止ignore()，如果ignore100个字符之后还没遇到值等于chEXP的字符，那也得停止ignore()，所以100是ignore()所忽略的最大字符数。</code></pre>删除缓冲区中数据，对缓冲区中的删除数据控制的较精确。</li><li>检验函数：<ul><li>eof():用于判断最后一次读取数据时候是否遇到文件结尾，若是返回true</li><li>fail():用于判断最后一次读取数据的时候是否遇到了类型不配的情况，若是返回true（如果遇到了EOF，该方法也返回true）</li><li>bad():如果出现意外的问题，如文件受损或硬件故障，最后一次读取数据的时候发生了这样的问题，方法bad()将返回true</li><li>good():该方法在没有发生任何错误的时候返回true。该方法也指出的最后一次读取输入的操作是否成功。<blockquote><p>文件读写：ifstream.h(输入文件流) ofstream.h(输出文件流) fstream.h</p><blockquote><p>open(filename，flag)：打开指定的文件</p><blockquote><p>flag: </p></blockquote></blockquote></blockquote><ol><li>ios::out 写 文件不存在 则建立新文件 文件存在则直接清空文件内容。</li><li>ios::in 读 文件不存在 就无法打开。</li><li>ios::app 追加 不能单独使用 否则无法打开。</li><li>ios::in |ios::app 读追加 文件不存在 就无法打开。</li><li>ios::out|ios::app 写追加 文件不存在 则建立新文件 文件存在则保留内容继续在末尾追加。打开文件后 文件指针 在开始处，一旦即将写 文件指针移到 文件末尾开始完成写操作。</li></ol></li><li>close():关闭文件和清除缓存区</li></ul></li><li>str():[使用时要调用sstream.h文件]返回一个字符串对象，该对象是缓冲区内容的副本.<ul><li>可以拿来读取文件信息，同时把文件中不需要的信息排除掉，格式如下：<blockquote><p>#include<sstream><br>#include<fstream><br>ifstream infile(“name”);<br>if(infile){<br>  string line;<br>  stringstream ss;<br>  int i;<br>  while(getline(infile,line)){</fstream></sstream></p><pre><code>ss.str(line);ss.clear();if(ss&gt;&gt;i)    cout &lt;&lt; i;</code></pre><p>  }<br>}</p></blockquote></li></ul></li><li>vectord的使用（vector.h）：<ol><li>定义方式：vector<type> vector_name[initial_size];</type></li><li>一些函数使用:(PS:字符串(sting)也可以用到下列函数)<blockquote><p>size():                  得出vector的元素数量<br>empty():                 检验vector是否含有元素，如果没有就返回true<br>push_back(element):      在vector的末尾添加元素<br>pop_back()：             在vector的末尾删除元素<br>back():                  返回到vector的末尾元素的引用<br>front():                 返回到vector的起始元素的引用<br>at(index):               返回到vector的指定位置<br>clear():                 删除所以元素<br>begin():                 返回初始元素的迭代器<br>insert(iterator,element):讲element插入到vector对应的位置（iterator）<br>erase(iterator)         :删除vector对应位置(iterator)的元素</p></blockquote></li></ol></li><li>string对应vector额外添加几个函数：<ol><li>substr(i,len)：     返回一个新的字符串，从第i个字符开始至i+len处；如果引用该函数不写len参数时，默认从i到末尾。</li><li>replace(i,len,str)：将i至i+len的字符替换为str。<blockquote><p>islower(i)：判断i处的字符是否是小写，是的话返回true。<br>isupper(i)：判断i处的字符是否是大写，是的话返回true。<br>isalpha(i)：判断i处的字符是否是英文字母，是的话返回true。<br>isdigit(i)：判断i处的字符是否是数字，是的话返回true。<br>isalnum(i)：判断i处的字符是否是数字或者英文字母，是的话返回true。<br>isspace(i)：判断i处的字符是否是空白格或者是\t,\n，是的话返回true。<br>ispunct(i)：判断i处的字符是否是标点符号，是的话返回true。、<br>isprint(i)：判断i处的字符是否是可打印的字符，包括空间字符（不包括空白字符），是的话返回true。</p></blockquote></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C/C+ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="/2020/04/26/FreeRTOS/"/>
      <url>/2020/04/26/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS任务创建和删除"><a href="#FreeRTOS任务创建和删除" class="headerlink" title="FreeRTOS任务创建和删除"></a>FreeRTOS任务创建和删除</h1><ol><li>创建任务分为动态创建和静态创建：<ul><li>动态任务创建：    <blockquote><p>BaseType_t xTaskCreate(    TaskFunction_t pxTaskCode,          任务函数    </p><pre><code>const char * const pcName,          任务名称    const uint16_t usStackDepth,        任务堆栈大小void * const pvParameters,          传递给任务函数的参数    UBaseType_t uxPriority,             任务优先级    TaskHandle_t * const pxCreatedTask )任务句柄    </code></pre></blockquote></li><li>静态任务创建：    <blockquote><p>获取空闲任务地任务堆栈和任务控制块内存：vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,  任务控制块内存</p><pre><code>   StackType_t **ppxIdleTaskStackBuffer, 任务堆栈内存uint32_t *pulIdleTaskStackSize)       任务堆栈大小</code></pre><p>获取定时器服务任务的任务堆栈和任务控制块内存：vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,  任务控制块内存</p><pre><code>StackType_t **ppxIdleTaskStackBuffer, 任务堆栈内存uint32_t *pulIdleTaskStackSize)       任务堆栈大小</code></pre><p>TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode,          任务函数</p><pre><code>const char * const pcName,          任务名称const uint32_t ulStackDepth,        任务堆栈大小void * const pvParameters,          传递给任务函数的参数UBaseType_t uxPriority,             任务优先级StackType_t * const puxStackBuffer, 任务堆栈StaticTask_t * const pxTaskBuffer ) 任务控制块  </code></pre></blockquote><ul><li>PS：使用静态任务时要将 configSUPPORT_STATIC_ALLOCATION 设为 1     </li><li>动态和静态创建任务的区别：静态任务需要用户来提供空闲任务的任务堆栈和任务控制块的内存和定时器服务任务的任务堆栈和任务控制块内存（静态内存），而动态任务由系统提供。</li></ul></li></ul></li><li>开启任务调度：vTaskStartScheduler()</li><li>删除任务：vTaskDelete( TaskHandle_t xTaskToDelete )    <h1 id="FreeRTOS任务挂起和恢复"><a href="#FreeRTOS任务挂起和恢复" class="headerlink" title="FreeRTOS任务挂起和恢复"></a>FreeRTOS任务挂起和恢复</h1></li><li>任务挂起：vTaskSuspend( TaskHandle_t xTaskToSuspend )</li><li>任务恢复：vTaskResume( TaskHandle_t xTaskToResume )<br> 使用时要将 INCLUDE_vTaskSuspend 设为 1 <h1 id="FreeRTOS列表项插入和删除"><a href="#FreeRTOS列表项插入和删除" class="headerlink" title="FreeRTOS列表项插入和删除"></a>FreeRTOS列表项插入和删除</h1></li><li>初始化列表  ：vListInitialise( List_t * const pxList )    </li><li>初始化列表项：vListInitialiseItem( ListItem_t * const pxItem )</li><li>列表结构体：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">angelscript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  &gt; <span class="keyword">typedef</span> struct xLIST</span><br><span class="line">&#123;</span><br><span class="line">listFIRST_LIST_INTEGRITY_CHECK_VALUE(<span class="number">1</span>)</span><br><span class="line">configLIST_VOLATILE UBaseType_t uxNumberOfItems;(<span class="number">2</span>)</span><br><span class="line">ListItem_t * configLIST_VOLATILE pxIndex;(<span class="number">3</span>)</span><br><span class="line">MiniListItem_t xListEnd;(<span class="number">4</span>)</span><br><span class="line">listSECOND_LIST_INTEGRITY_CHECK_VALUE(<span class="number">5</span>)</span><br><span class="line">&#125; List_t;</span><br><span class="line"> * (<span class="number">1</span>)和(<span class="number">5</span>)都是用来检查列表完整性的，需要将宏configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 设置为 <span class="number">1</span> ，开启以后会向这两个地方分别添加一个变量xListIntegrityValue1和xListIntegrityValue2，在初始化列表的时候会这两个变量中写入一个特殊的值，默认不开启这个功能。</span><br><span class="line"> * (<span class="number">2</span>)uxNumberOfItems用来记录列表中列表项的数量。</span><br><span class="line"> * (<span class="number">3</span>)pxIndex用来记录当前列表项索引号，用于遍历列表。</span><br><span class="line"> * (<span class="number">4</span>)列表中最后一个列表项，用来表示列表结束，此变量类型为MiniListItem_t，这是一个迷你列表项。</span><br></pre></td></tr></table></figure></div></li><li>列表项结构体：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">angelscript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  struct xLIST_ITEM</span><br><span class="line"> &#123;</span><br><span class="line">listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(<span class="number">1</span>)</span><br><span class="line">configLIST_VOLATILE TickType_t xItemValue;(<span class="number">2</span>)</span><br><span class="line">struct xLIST_ITEM * configLIST_VOLATILE pxNext;(<span class="number">3</span>)</span><br><span class="line">struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">void</span> * pvOwner;(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">void</span> * configLIST_VOLATILE pvContainer;(<span class="number">6</span>)</span><br><span class="line">listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(<span class="number">7</span>)</span><br><span class="line">&#125;;</span><br><span class="line">* (<span class="number">1</span>)和(<span class="number">7</span>)用法和列表一样，用来检查列表项完整性。</span><br><span class="line">* (<span class="number">2</span>)xItemValue为列表值。</span><br><span class="line">* (<span class="number">3</span>)pxNext指向下一个列表项。</span><br><span class="line">* (<span class="number">4</span>)pxPrevious指向前一个列表项，和pxNext配合起来实现类似双向链表的功能。</span><br><span class="line">* (<span class="number">5</span>)pvOwner记录此链表项归谁拥有，通常是任务控制块。</span><br><span class="line">* (<span class="number">6</span>)pvContainer用来记录此列表项归哪个列表。</span><br></pre></td></tr></table></figure></div></li><li>迷你列表项结构体：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">angelscript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   struct xMINI_LIST_ITEM</span><br><span class="line">&#123;</span><br><span class="line">listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(<span class="number">1</span>)</span><br><span class="line">configLIST_VOLATILE TickType_t xItemValue;(<span class="number">2</span>)</span><br><span class="line">struct xLIST_ITEM * configLIST_VOLATILE pxNext;(<span class="number">3</span>)</span><br><span class="line">struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; (<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br><span class="line"> * (<span class="number">1</span>)用来检查迷你列表项完整性。</span><br><span class="line"> * (<span class="number">2</span>) xItemValue记录列表列表项值。</span><br><span class="line"> * (<span class="number">3</span>) pxNext指向下一个列表项。</span><br><span class="line"> * (<span class="number">4</span>) pxPrevious指向上一个列表项。</span><br></pre></td></tr></table></figure></div></li><li>插入列表项：vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )</li><li>删除列表项：uxListRemove( ListItem_t * const pxItemToRemove )</li><li>列表末尾添加列表项：vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )<h1 id="FreeRTOS任务状态或信息查询以及任务运行时间统计"><a href="#FreeRTOS任务状态或信息查询以及任务运行时间统计" class="headerlink" title="FreeRTOS任务状态或信息查询以及任务运行时间统计"></a>FreeRTOS任务状态或信息查询以及任务运行时间统计</h1><blockquote><p><a href="https://cdn.jsdelivr.net/gh/CQY-Z/BLOG_PICTURE@v0.0.5/API.png" data-fancybox="group" data-caption=" " class="fancybox"><img alt=" " title=" " data-src="https://cdn.jsdelivr.net/gh/CQY-Z/BLOG_PICTURE@v0.0.5/API.png" class="lazyload"></a></p></blockquote></li><li>获取系统中任务状态步骤：<ul><li>获取系统任务数量: uxTaskGetNumberOfTasks()    </li><li>申请内存：*pvPortMalloc( size_t xWantedSize )</li><li>获取系统中任务状态：uxTaskGetSystemState(TaskStatus_t * const pxTaskStatusArray, 任务信息存储数组<pre><code>const UBaseType_t uxArraySize,          任务信息存储数组大小uint32_t * const pulTotalRunTime )      保存系统总的运行时间</code></pre></li><li>释放内存：vPortFree( void *pv )</li></ul></li><li>获取某个任务信息步骤：<ul><li>根据任务名获取任务句柄：xTaskGetHandle( const char *pcNameToQuery )</li><li>获取任务信息：vTaskGetInfo( TaskHandle_t xTask,            任务句柄<pre><code>   TaskStatus_t *pxTaskStatus,    任务信息结构体  BaseType_t xGetFreeStackSpace, 允许统计任务堆栈历史最小剩余大小eTaskState eState )            函数自己获取任务运行壮态</code></pre></li></ul></li><li>获取某个任务的状态步骤：<ul><li>根据任务名获取任务句柄：xTaskGetHandle( const char *pcNameToQuery )</li><li>获取任务的任务壮态：eTaskGetState( TaskHandle_t xTask )</li></ul></li><li>获取任务运行时间信息：<ul><li>宏定义 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS(),此宏用来初始化一个外设来提供时间统计功能所需的时基，一般是定时器/计数器。这个时基的分辨率一定要比FreeRTOS的系统时钟高，一般时钟精度比系统时钟的高10~20倍。</li><li>portGET_RUN_TIME_COUNTER_VALUE()或者portALT_GET_RUN_TIME_COUNTER_VALUE(Time)；二选一，用于提供当前的时基的时间值。</li><li>获取任务运行时间信息：vTaskGetRunTimeStats( char *pcWriteBuffer )<h1 id="FreeRTOS内核控制函数"><a href="#FreeRTOS内核控制函数" class="headerlink" title="FreeRTOS内核控制函数"></a>FreeRTOS内核控制函数</h1><blockquote><p><a href="https://cdn.jsdelivr.net/gh/CQY-Z/BLOG_PICTURE@v0.0.5.1/KELNAL.png" data-fancybox="group" data-caption=" " class="fancybox"><img alt=" " title=" " data-src="https://cdn.jsdelivr.net/gh/CQY-Z/BLOG_PICTURE@v0.0.5.1/KELNAL.png" class="lazyload"></a></p></blockquote></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unbuntu中的TIM中文显示问题</title>
      <link href="/2020/02/15/Ubuntu%E4%B8%AD%E7%9A%84TIM%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/15/Ubuntu%E4%B8%AD%E7%9A%84TIM%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><pre><code>前段时间安装完了Ubuntu，想着给Ubuntu上下个TIM方便通信（用的是deepin-wine）。但是在网上找了下载步骤下好之后，中文字体无法正常显示（但是登录之后别人发的信息是可以看清楚的），让我很难受，找了资料发现是少了字体（中文以乱码形式出现大部分情况下就是缺少字体，我也不是很清楚），如下图：</code></pre><p>  <a href="https://cdn.jsdelivr.net/gh/CQY-Z/BLOG_PICTURE@v0.0.2/1.jpg" data-fancybox="group" data-caption=" " class="fancybox"><img alt=" " title=" " data-src="https://cdn.jsdelivr.net/gh/CQY-Z/BLOG_PICTURE@v0.0.2/1.jpg" class="lazyload"></a>  </p><ul><li>解决方案比较简单粗暴，因为看网上的大部分都是虚拟机（博主的是双系统Ubuntu+win10）  </li></ul><hr><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h1><ul><li>第一步:启动WIN10系统并准备一个移动盘（U盘或者移动硬盘），找到存放字体的路径（C:\Windows\Fonts）  </li><li>第二步:将里面带有.ttf和.ttc的字体复制到移动盘当中（只留中文字体也行）  </li><li>第三步:启动Ubuntu，将字体移植到TIM使用字体的路径（.deepinwine\Deepin-TIM\drive_c\windows\Fonts）<br>之后重启TIM，就正常显示中文了  </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Unbuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unbuntu遇到的问题</title>
      <link href="/2020/02/09/Ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/02/09/Ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="安装时遇到的问题"><a href="#安装时遇到的问题" class="headerlink" title="安装时遇到的问题"></a>安装时遇到的问题</h1><hr><h2 id="打开grub文件"><a href="#打开grub文件" class="headerlink" title="打开grub文件"></a>打开grub文件</h2><pre><code>sudo gedit /etc/default/grub打开一个文件  </code></pre><h2 id="进入后把："><a href="#进入后把：" class="headerlink" title="进入后把："></a>进入后把：</h2><pre><code>GRUB_CMDLINE_LINUX_DEFAULT= &quot;quiet splash&quot;  GRUB_CMDLINE_LINUX=&quot;&quot;  </code></pre><h2 id="分别改成："><a href="#分别改成：" class="headerlink" title="分别改成："></a>分别改成：</h2><pre><code>GRUB_CMDLINE_LINUX_DEFAULT= &quot;quiet splash nomodeset&quot;  GRUB_CMDLINE_LINUX= &quot;apm power_off=1&quot;  </code></pre><h2 id="然后更新一下文件："><a href="#然后更新一下文件：" class="headerlink" title="然后更新一下文件："></a>然后更新一下文件：</h2><pre><code>sudo update-grub  </code></pre><blockquote><p>可能可解决的问题：开机卡死、关机卡死、开机后自动关机  </p></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Unbuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指令内容</title>
      <link href="/2020/02/09/Git%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/02/09/Git%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Git中四个区域"><a href="#Git中四个区域" class="headerlink" title="Git中四个区域:"></a>Git中四个区域:</h1><hr><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Workspace：工作区  </span><br><span class="line">Stage：暂存区  </span><br><span class="line">Repository：仓库区（或本地仓库）  </span><br><span class="line">Remote：远程仓库</span><br></pre></td></tr></table></figure></div><hr><h1 id="Git操作指令："><a href="#Git操作指令：" class="headerlink" title="Git操作指令："></a>Git操作指令：</h1><hr><h2 id="1-常用指令"><a href="#1-常用指令" class="headerlink" title="1. 常用指令"></a>1. 常用指令</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">routeros</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-从对应的远程仓库中克隆内容:  $ git clone [url]  </span><br><span class="line">-查看当前本地仓库中的文件状态:  <span class="variable">$git</span> status  </span><br><span class="line">-查看当前远程仓库地址:  $ git remote -v  </span><br><span class="line">-添加远程仓库,与远程仓库连接:  $ git remote <span class="builtin-name">add</span> [name] [url]  </span><br><span class="line">-将本地仓库内容推送到远程仓库:  $ git push [remoteName] [localBranchName][^RUNOOB1]  </span><br><span class="line">-添加说明:  <span class="variable">$git</span> commit -m <span class="string">"*Explanation*"</span>_  </span><br><span class="line">-拉取远程仓库信息:  $ git pull [remoteName] [localBranchName]  </span><br><span class="line">-解除与远程仓库的连接:  $ git remote rm [name]  </span><br><span class="line">-暂存改变或新建的内容:  $ git <span class="builtin-name">add</span> [name][^RUNOOB2]  </span><br><span class="line">-创键分支:  <span class="variable">$git</span> branch [name][^RUNOOB3]  </span><br><span class="line">-查看所有分支:  <span class="variable">$git</span> branch -a  </span><br><span class="line">-查看远程仓库内所有分支:  <span class="variable">$git</span> branch -r  </span><br><span class="line">-查看本地仓库分支:  <span class="variable">$git</span> branch  </span><br><span class="line">-切换分支:  <span class="variable">$git</span> checkout [name]  </span><br><span class="line">-合并分支:  <span class="variable">$git</span> merge [name]  </span><br><span class="line">-查看版本号:  <span class="variable">$git</span> log  </span><br><span class="line">-退回到目标版本号:  <span class="variable">$git</span> reset --hard 目标版本号  </span><br><span class="line">-显示当前的GIT配置:  <span class="variable">$git</span><span class="built_in"> config </span>--list [^RUNOOB4]  </span><br><span class="line">-设置用户名:  <span class="variable">$git</span><span class="built_in"> config </span>--global user.name[username]  </span><br><span class="line">-设置邮箱地址:  <span class="variable">$git</span><span class="built_in"> config </span>--global user.email[email]</span><br></pre></td></tr></table></figure></div><h2 id="2-在本地创建SSH公钥"><a href="#2-在本地创建SSH公钥" class="headerlink" title="2. 在本地创建SSH公钥"></a>2. 在本地创建SSH公钥</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">haml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">生成SHH <span class="symbol">KEY:</span>  $ ssh-keygen -t rsa -C <span class="string">"xxxxxxxxx@pp.com"</span>  </span></span><br><span class="line"><span class="ruby">-验证算否成功:  $ ssh -T git@github.com</span></span><br></pre></td></tr></table></figure></div><h2 id="3-细致操作指令"><a href="#3-细致操作指令" class="headerlink" title="3. 细致操作指令"></a>3. 细致操作指令</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">haml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   -<span class="ruby">删除工作区文件并放进暂存区:  $git rm [filename]  </span></span><br><span class="line"><span class="ruby">   -将文件从暂存区撤销:  $git reset HEAD --[filename]  </span></span><br><span class="line"><span class="ruby">   -撤销工作区的文件修改:  $git checkout --[filename]  </span></span><br><span class="line"><span class="ruby">   -停止追踪文件,但此文件会保留在工作区中[^RUNOOB3]:  $git rm --cached[filename]  </span></span><br><span class="line"><span class="ruby">   -配置Git显示颜色:  $git config --global color.ui <span class="literal">true</span>  </span></span><br><span class="line"><span class="ruby">   -创键远程的分支到本地:  $git checkout -b [branch][remote]/[branch]  </span></span><br><span class="line"><span class="ruby">   -比较工作区文件与暂存区文件的差异:  $git diff [filename]  </span></span><br><span class="line"><span class="ruby">   -比较暂存区的文件与上一次commit的差异:  $git diff --cached [filename]  </span></span><br><span class="line"><span class="ruby">   -比较工作区的文件与当前分支最新commit之间的差异<span class="symbol">:</span>$git diff HEAD -- [filename]  </span></span><br><span class="line"><span class="ruby">   -未使用git add添加到暂存区中的文件也一起提交:  $git commit -a -m <span class="string">"*Explanation*"</span>  </span></span><br><span class="line"><span class="ruby">   -查看commit历史:  $git log --stat  </span></span><br><span class="line"><span class="ruby">   -查看从最近到最远的提交日志简单日志:  $git log --pretty=oneline  </span></span><br><span class="line"><span class="ruby">   -查看最近n次的提交信息:  $git log -n  </span></span><br><span class="line"><span class="ruby">   -查看分支合并图:  $git log --graph  </span></span><br><span class="line"><span class="ruby">   -查看分支合并图与简单日志:  $git log --graph --pretty=online  </span></span><br><span class="line"><span class="ruby">   -查看命令历史:  $git reflog  </span></span><br><span class="line"><span class="ruby">   -查看指定文件是什么人在什么时间修改过:  $git blame [filename]  </span></span><br><span class="line"><span class="ruby">   -查看所有提交过的用户:  $git shortlog -sn  </span></span><br><span class="line"><span class="ruby">   -合并指定分支[branch]到当前分支[message]:  $git merge --no-ff -m[message][branch]  </span></span><br><span class="line"><span class="ruby">   -查看使用储藏起来的工作现场:  $git stash list  </span></span><br><span class="line"><span class="ruby">   -恢复工作现场:  $git stash apply  </span></span><br><span class="line"><span class="ruby">   -删除stash内容:  $git stash drop  </span></span><br><span class="line"><span class="ruby">   -恢复工作现场并删除stash内容:  $git stash pop  </span></span><br><span class="line"><span class="ruby">   -为当前HEAD打标签:  $git tag [tagname]  </span></span><br><span class="line"><span class="ruby">   -为本地tag添加说明:  $git tag [tagname] commitld 或者 $git tag -a[tagname] -m[message]commitld  </span></span><br><span class="line"><span class="ruby">-查看所有标签:  $git tag  </span></span><br><span class="line"><span class="ruby">-查看某个tag信息:  $git show [tagname]  </span></span><br><span class="line"><span class="ruby">-删除本地标签:  $git tag -d[tagname]  </span></span><br><span class="line"><span class="ruby">-删除远程标签:  $git tag -d[tagname] -&gt; git push [remote]<span class="symbol">:refs/tags/</span>[tagname]  </span></span><br><span class="line"><span class="ruby">-新建一个分支并且指向某个<span class="symbol">tag:</span>  $git checkout -b[branch][tagname]  </span></span><br><span class="line"><span class="ruby">-从远程的origin仓库的master分支下载代码到本地的origin <span class="symbol">master:</span>  $git fetch origin master  </span></span><br><span class="line"><span class="ruby">-从远程的origin仓库的master分支下载道本地并新建一个分支<span class="symbol">temp:</span>  $git fech origin <span class="symbol">master:</span>temp  </span></span><br><span class="line"><span class="ruby">-比较本地的仓库和远程仓库的区别:  $git log -p master..origin/master</span></span><br><span class="line"><span class="ruby">   -一个项目传到多个远程仓库（假设已经存在一个名为origin的远程仓库了）:  $ git remote set-url --push[name][newUrl]</span></span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">routeros</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[^RUNOOB1]: *当本地仓库版本比远程仓库的要旧时，使用指令* _<span class="variable">$git</span> push -f_  </span><br><span class="line">[^RUNOOB2]: _<span class="variable">$git</span> <span class="builtin-name">add</span> ._ *和* _<span class="variable">$git</span> <span class="builtin-name">add</span> all_ *是暂存所有有变动包括新建的文件*  _<span class="variable">$git</span> <span class="builtin-name">add</span> -u_ *表示添加编辑和删掉的文件，不包括新添加的文件*  </span><br><span class="line">[^RUNOOB3]: *untracked状态*  </span><br><span class="line">[^RUNOOB4]: &gt; *查看用户名*:_<span class="variable">$git</span><span class="built_in"> config </span>user.name  </span><br><span class="line">            &gt; *查看邮箱地址*:_<span class="variable">$git</span><span class="built_in"> config </span>user.email_</span><br></pre></td></tr></table></figure></div><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
